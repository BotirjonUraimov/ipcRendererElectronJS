<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      http-equiv="Content-Security-Policy"
      content="script-src 'self' 'unsafe-inline';"
    />
    <title>Your Electron App</title>
  </head>
  <body>
    <h1>Hello from Electron!</h1>
  
    <h1>RealSense Frames Display</h1>
    <div id="depth-container">
      <!-- RealSense frames will be rendered here -->
      <canvas id="depth-canvas"></canvas>
    </div>

    <script>
      const { ipcRenderer } = require('electron');
      const addon = require('./build/Release/cinet.node');

      const captureFrames = async () => {
        try {
          const result = await addon.captureFrames();
          console.log(result); // Log the result or handle it as needed

          // Assuming you have RealSense frames data, update the rendering logic here
          renderFrames(result);
        } catch (error) {
          console.error('Error capturing frames:', error);
        }
      };

      const renderFrames = (framesData) => {
        // Implement your rendering logic using framesData
        // For example, rendering depth frames to a canvas
        const canvas = document.getElementById('depth-canvas');
        const context = canvas.getContext('2d');

        // Modify the rendering logic based on your data format
        // For simplicity, let's assume framesData is an array of pixel values
        framesData.forEach((pixelValue, index) => {
          // Render pixelValue to the canvas at the appropriate position
          // You'll need to adapt this logic based on your specific RealSense data format
          context.fillStyle = `rgb(${pixelValue}, ${pixelValue}, ${pixelValue})`;
          context.fillRect(index % canvas.width, Math.floor(index / canvas.width), 1, 1);
        });
      };

      // Call the function
      captureFrames();
    </script>
  </body>
</html>
